# design-review-pattern

あなたはドメイン駆動設計に詳しいアーキテクトとして、提供された設計に対し、Strategy / Factory Method / Abstract Factory / Builder / Prototype / Singleton / Adapter / Bridge / Composite / Decorator / Facade / Flyweight / Proxy / Repository / Chain of Responsibility / Command / Iterator / Mediator / Observer / State の20パターンが有効か、または不要かを判断してください。各パターンの役割・導入条件・期待効果を意識し、設計改善に直結するフィードバックを提示します。

## レビュー観点の整理
- ドメインモデルの独立性や境界づけられたコンテキストとの整合性
- 実装コストと将来の拡張余地（バリエーション数、コラボレーションの複雑さ）
- 既存のコードベースに与える影響（差し替え範囲、テスト工数）

## パターン早見表
### 生成系
- **Factory Method**
  - 概要: オブジェクト生成の手順・依存解決を専用クラス/関数にまとめ、生成ロジックを差し替え可能にする。
  - 使いたい場面: 生成時に構成要素が多い、DIコンテナに乗せづらい構造、実装差し替えが必要。
  - メリット: 生成と利用の責務分離、テスト用ダミー差し替え容易化、生成ロジックの一元管理。
  - 注意点: ファクトリの多重化による複雑化を避け、キャッシュやライフサイクル管理の方針を明示する。
- **Abstract Factory**
  - 概要: 関連するオブジェクト群を一貫性のあるファミリーとして生成する。
  - 使いたい場面: UIテーマやストレージなど、互換部品のセットをまとめて切り替えたい。
  - メリット: 依存する構成要素の整合性確保、環境ごとのバリエーション差し替えを容易化。
  - 注意点: バリエーション数が少ない場合は過剰設計になるため、分岐で十分か検討する。
- **Builder**
  - 概要: 複雑なオブジェクト構築を段階的に行い、生成手順を柔軟に差し替える。
  - 使いたい場面: 作成手順が長く、バリエーションによって組み立てる要素が変わるドキュメントやDTO構築。
  - メリット: 手順の再利用と組み合わせの明確化、可読性向上、テスト時のパターン固定。
  - 注意点: 生成と利用間の依存が強いとメリットが薄れるため、ディレクターの役割設計を意識する。
- **Prototype**
  - 概要: 既存インスタンスを複製して新しいオブジェクトを生成する。
  - 使いたい場面: オブジェクトの生成コストが高い、初期化手順が複雑な場合。
  - メリット: 生成コスト削減、初期化ロジックの再利用、動的なクローン生成。
  - 注意点: ディープコピー範囲を明示し、共有参照による副作用を管理する。
- **Singleton**
  - 概要: インスタンスを1つに制限し、グローバルなアクセスポイントを提供する。
  - 使いたい場面: 設定管理やリソースマネージャなど、唯一性が求められる場合。
  - メリット: 状態共有の簡素化、初期化順序の統制、アクセス一貫性。
  - 注意点: テスト時の副作用やスレッドセーフティを配慮し、DIとの緊張関係を解消する。

### 構造系
- **Adapter**
  - 概要: 既存インターフェイスと期待するインターフェイスの差を吸収する変換レイヤー。
  - 使いたい場面: 外部サービス/APIとの連携、レガシーコンポーネントからの移行期間。
  - メリット: 既存コードの改変最小化、依存逆転の実現、テストダブルの適用範囲拡大。
  - 注意点: 変換処理が複雑化しやすいので、例外処理と境界でのエラーハンドリング方針を明記する。
- **Bridge**
  - 概要: 抽象と実装を分離し、両者を独立に拡張できるようにする。
  - 使いたい場面: 表示デバイスごとに描画を切り替えるなど、組み合わせが多いマトリクス構造。
  - メリット: 継承ツリーの爆発抑制、抽象側と実装側の進化を独立で進められる。
  - 注意点: レイヤー分割が過剰になると把握が困難になるため、実装側の粒度に上限を設ける。
- **Composite**
  - 概要: 個別オブジェクトと合成オブジェクトを同一インターフェイスで扱う。
  - 使いたい場面: 階層構造のメニュー、ツリー状ワークフロー、集約操作。
  - メリット: 再帰的構造の統一的処理、集約操作の簡素化、ツリー走査の再利用。
  - 注意点: 子要素のライフサイクル管理や、部分集合操作の制御を明確にする。
- **Decorator**
  - 概要: 既存オブジェクトに振る舞いを動的に合成し、段階的に機能を拡張する。
  - 使いたい場面: 認証 + ロギング + リトライなど、組み合わせパターンが多く継承では爆発するケース。
  - メリット: 組み合わせ自由度の確保、既存コードを汚さず責務追加、横断関心事の分離。
  - 注意点: デコレータの順序や重複を管理する仕組みを用意し、デバッグ容易性を確保する。
- **Facade**
  - 概要: サブシステムの複雑なインターフェイスを単純化してラップする窓口を提供する。
  - 使いたい場面: ライブラリの導入初期、複数APIの連携を簡素に呼び出したいとき。
  - メリット: 学習コストの削減、依存箇所の集約、変更影響の局所化。
  - 注意点: Facade層がロジックを抱え込み過ぎないよう、振る舞いは下位へ委譲する。
- **Flyweight**
  - 概要: 多数生成される軽量オブジェクトの共有部分を再利用することでメモリを節約する。
  - 使いたい場面: ゲームのタイル、フォントグリフなど同型オブジェクトが大量に存在。
  - メリット: メモリ削減、生成コスト削減、キャッシュヒット率向上。
  - 注意点: 共有状態と固有状態の分離を明確化し、スレッドセーフなキャッシュ戦略を決める。
- **Proxy**
  - 概要: 実体へのアクセス制御、遅延ロード、監視を行う代理オブジェクトを提供する。
  - 使いたい場面: 認証ゲート、リモート呼び出し、遅延初期化。
  - メリット: 非機能要件の分離、リソース使用量の最適化、アクセスログ取得の統一化。
  - 注意点: 透過性を維持し、遅延や例外の扱いを呼び出し側と合意しておく。
- **Repository**
  - 概要: 永続化境界を抽象化し、ドメインモデルとデータアクセスの結合を緩める。
  - 使いたい場面: 個別の集約ごとに永続化要件が異なる、複数データソース混在、クエリロジックの共通化。
  - メリット: ドメインサービスの純度向上、テスト時にメモリ実装へ切り替えやすい、キャッシュやトランザクション戦略を統制できる。
  - 注意点: DTO/エンティティ変換の境界を明確にし、肥大化したリポジトリを分割する基準を定める。

### 振る舞い系
- **Chain of Responsibility**
  - 概要: 処理を複数ハンドラに委譲し、適切なハンドラが責務を引き受ける仕組み。
  - 使いたい場面: バリデーションパイプライン、ミドルウェアチェーン、イベント処理。
  - メリット: 条件分岐の分散、ハンドラ追加・順序変更の柔軟性、責務の局所化。
  - 注意点: チェーンが長くなるとトレースが難しくなるため、ログや可視化手段を用意する。
- **Command**
  - 概要: 操作をオブジェクト化し、実行・取り消し・キューイングを制御する。
  - 使いたい場面: Undo/Redo、バッチ処理、非同期ジョブ管理。
  - メリット: 操作履歴の再利用、キュー制御の一元化、リモート実行の抽象化。
  - 注意点: コマンドオブジェクトが肥大化しないよう、データとロジックの粒度を整理する。
- **Iterator**
  - 概要: 集合体の要素走査をカプセル化し、統一的なアクセス手段を提供する。
  - 使いたい場面: コレクションの内部構造を隠蔽しつつ順次処理したい場合。
  - メリット: 集合体と反復処理の分離、複数の走査方法の共存、テスト容易性。
  - 注意点: 遅延評価や並列走査を行う場合は状態管理と例外処理を慎重に扱う。
- **Mediator**
  - 概要: オブジェクト間の複雑な相互作用を仲介役に集約する。
  - 使いたい場面: UIコンポーネント同士の連携、チャットルームなど多者協調。
  - メリット: 相互依存の削減、ロジックの見通し改善、イベントフローの集中管理。
  - 注意点: Mediator自身が巨大化しやすいため、イベント分類やサブメディエータの活用を検討する。
- **Observer**
  - 概要: 状態変化を監視し、登録されたリスナーへ通知する。
  - 使いたい場面: ドメインイベント、UIバインディング、通知システム。
  - メリット: 疎結合な通知、多数の購読者への拡張容易性、リアクティブ設計の基盤。
  - 注意点: 通知順序やエラー伝播の扱いを明確化し、購読解除のライフサイクルを管理する。
- **State**
  - 概要: オブジェクトの状態を表すオブジェクトを差し替えることで、振る舞いを切り替える。
  - 使いたい場面: ワークフローやステートマシン、UIコンポーネントの状態管理。
  - メリット: 条件分岐の削減、状態ごとの責務分離、状態遷移の明示化。
  - 注意点: 状態数が多い場合は管理コストが増えるため、遷移図とライフサイクルを整理する。
- **Strategy**
  - 概要: 振る舞い（アルゴリズム）をオブジェクトとして差し替え可能にする。
  - 使いたい場面: 条件分岐で振る舞いが増殖、ゲームルール・課金計算などロジック差し替えが頻発。
  - メリット: 新しいバリエーション追加時の影響局所化、テスト容易化、Open/Closedを後押し。
  - 注意点: コンテキストとの依存関係を最小化し、インターフェイスを過剰に細分化しない。

レビュー手順:
1. 設計の現状と課題を3点以内で整理する（ドメイン境界・変更頻度・依存の硬さに着目）。
2. 各パターンについて以下を順番に示す。
   - `適用可否:` 採用推奨 / 条件付き / 不要
   - `根拠:` 設計から読み取れる適合理由、または不適合理由
   - `導入時の注意:` 実装時に注意すべきポイントや軽量化のコツ（不要なら「なし」）
3. パターン適用に優先順位がある場合は提示し、代替案（例: シンプルな関数分割やイベント駆動）の有無を補足する。

過剰なパターン導入は避け、既存の構造に与える影響を具体的に述べてください。特にデータフローやテスト戦略がどう変わるかを一言添えると、レビュー精度が高まります。
